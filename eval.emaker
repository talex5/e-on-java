def ObjectExpr := <type:org.erights.e.elang.evm.ObjectExpr>
def FinalPattern := <type:org.erights.e.elang.evm.FinalPattern>
def SlotPattern := <type:org.erights.e.elang.evm.SlotPattern>
def VarPattern := <type:org.erights.e.elang.evm.VarPattern>
def OuterNounExpr := <type:org.erights.e.elang.evm.OuterNounExpr>
def SlotExpr := <type:org.erights.e.elang.evm.SlotExpr>
def LocalFinalNounExpr := <type:org.erights.e.elang.evm.LocalFinalNounExpr>
def LiteralExpr := <type:org.erights.e.elang.evm.LiteralExpr>
def CallExpr := <type:org.erights.e.elang.evm.CallExpr>
def SeqExpr := <type:org.erights.e.elang.evm.SeqExpr>
def AssignExpr := <type:org.erights.e.elang.evm.AssignExpr>
def DefineExpr := <type:org.erights.e.elang.evm.DefineExpr>
def IfExpr := <type:org.erights.e.elang.evm.IfExpr>
def FrameFinalNounExpr := <type:org.erights.e.elang.evm.FrameFinalNounExpr>
def LocalSlotNounExpr := <type:org.erights.e.elang.evm.LocalSlotNounExpr>
def FrameSlotNounExpr := <type:org.erights.e.elang.evm.FrameSlotNounExpr>

def max(a, b) {
	if (a > b) {
		return a
	} else {
		return b
	}
}

def makeMethodCompiler(<asm>, queueCompileInnerClass) {
	return def compile(mw, className :String) {
		def eval

		def makeLabel := <asm:makeLabel>
		def Opcodes := <asm:makeOpcodes>
		def <op> {
			to get(code) {
				return E.call(Opcodes, `get$code`, [])
			}
		}

		def evalGuard(guard, valueMaker) {
			if (guard == null) {
				return valueMaker()
			}

			#E.call(foo, "coerce", specimen, optEjector);
			def guardStack := eval(guard)
			mw.visitLdcInsn("coerce");
			def maxStack := 2 + valueMaker() + 1
			mw.visitInsn(<op:ACONST_NULL>)	# XXX
			mw.visitMethodInsn(<op:INVOKESTATIC>, "org/erights/e/elib/prim/E", "call",
				"(Ljava/lang/Object;Ljava/lang/String;Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;")
			#mw.visitMethodInsn(<op:INVOKEVIRTUAL>, "org/erights/e/elib/slot/Guard", "coerce",
			#"(Ljava/lang/Object;Lorg/erights;Lorg/erights/e/elib/util/OneArgFunc;)Ljava/lang/Object;")
			return maxStack
		}

		# => slot, value
		def evalMakeSlot(pattern, valueMaker) {
			def guard := pattern.getOptGuardExpr()

			def valueStack := evalGuard(guard, valueMaker)

			if (pattern =~ sp :SlotPattern) {
				# The value is the slot
				mw.visitInsn(<op:DUP>)
				return max(2, valueStack)
			}

			# Package top-most value in a slot
			def slotType := switch (pattern) {
				match finalPattern :FinalPattern {
					"org/erights/e/elib/slot/FinalSlot"
				}
				match varPattern :VarPattern {
					if (guard == null) {
						"org/erights/e/elib/slot/SimpleSlot"
					} else {
						"org/erights/e/elib/slot/SettableSlot"
					}
				}
			}

			mw.visitTypeInsn(<op:NEW>, slotType);
			# stack: value, slot
			mw.visitInsn(<op:SWAP>)
			mw.visitInsn(<op:DUP2>)
			# stack: slot, value, slot, value

			mw.visitMethodInsn(<op:INVOKESPECIAL>, slotType, "<init>",
				"(Ljava/lang/Object;)V");

			# stack: slot, value
			return max(valueStack, 4)
		}

		def eLocalToJaveLocal(i) {
			return i + 2
		}

		def evalEInt(value :int) {
			# XXX: values longer than Long?
			mw.visitLdcInsn(value :<type:long>)
			mw.visitMethodInsn(<op:INVOKESTATIC>, "java/math/BigInteger", "valueOf",
						"(J)Ljava/math/BigInteger;")
			return 1
		}

		def evalIf(ifExpr) {
			def testStack := eval(ifExpr.getTest())
			#E.asBoolean(value)

			mw.visitMethodInsn(<op:INVOKESTATIC>, "org/erights/e/elib/prim/E", "asBoolean",
				"(Ljava/lang/Object;)Z")

			def elseBlock := makeLabel()
			def done := makeLabel()

			mw.visitJumpInsn(<op:IFEQ>, elseBlock)

			def thenStack := eval(ifExpr.getThen())
			mw.visitJumpInsn(<op:GOTO>, done)

			mw.visitLabel(elseBlock)
			def elseStack := eval(ifExpr.getElse())

			mw.visitLabel(done)

			return max(max(testStack, thenStack), elseStack)
		}

		def evalDefInteral(pattern, valueMaker) {
			def guard := pattern.getOptGuardExpr()
			def noun := pattern.getNoun()
			traceln(`def $noun (${noun.__getAllegedType()})`)
			switch (noun) {
				match lsNoun :LocalSlotNounExpr {
					def i := lsNoun.getIndex()
					def stackSlot := evalMakeSlot(pattern, valueMaker)
					mw.visitInsn(<op:DUP>)
					mw.visitIntInsn(<op:ASTORE>, eLocalToJaveLocal(i))
					return stackSlot
				}
				match lNoun :LocalFinalNounExpr {
					pattern :FinalPattern
					def i := lNoun.getIndex()
					def valueStack := evalGuard(guard, valueMaker)
					mw.visitInsn(<op:DUP>)
					mw.visitIntInsn(<op:ASTORE>, eLocalToJaveLocal(i))
					return valueStack
				}
				match oNoun :OuterNounExpr {
					def i := oNoun.getIndex()
					# this.outers[i] := new Slot(value)
					mw.visitVarInsn(<op:ALOAD>, 0);
					mw.visitFieldInsn(<op:GETFIELD>, className, "outers", "[Lorg/erights/e/elib/slot/Slot;")
					# stack: outers
					def stackSlot := evalMakeSlot(pattern, valueMaker)
					# stack: outers, slot, value
					mw.visitInsn(<op:DUP_X2>)
					mw.visitInsn(<op:POP>)
					# stack: value, outers, slot
					mw.visitLdcInsn(i)
					mw.visitInsn(<op:SWAP>)
					# stack: value, outers, i, slot
					mw.visitInsn(<op:AASTORE>)
					# stack: value
					return 70
				}
			}
		}

		def evalDef(pattern, value) {
			return evalDefInteral(pattern, fn { eval(value) })
		}

		def evalObjectDef(objExpr) {
			return evalDefInteral(objExpr.getOName(), fn {
				def newObjClass := queueCompileInnerClass(objExpr)

				def oName := objExpr.getOName()

				mw.visitTypeInsn(<op:NEW>, newObjClass)
				mw.visitInsn(<op:DUP>)
				mw.visitVarInsn(<op:ALOAD>, 0);
				mw.visitFieldInsn(<op:GETFIELD>, className, "outers", "[Lorg/erights/e/elib/slot/Slot;")

				# Create a new array for the fields (non-outer variables in scope of the object and
				# used inside the object).
				def fields := objExpr.optFieldNouns()
				mw.visitIntInsn(<op:BIPUSH>, fields.size())
				mw.visitTypeInsn(<op:ANEWARRAY>, "java/lang/Object")
				# stack: object, context, array
				var maxStack := 4
				for i => field in fields {
					mw.visitInsn(<op:DUP>)
					mw.visitLdcInsn(i);
					traceln(`field $i (${i.__getAllegedType()})`)
					# stack: object, context, array, array, i
					def stackForField := eval(field) + 5
					mw.visitInsn(<op:AASTORE>)
					if (stackForField > maxStack) {
						maxStack := stackForField
					}
				}

				mw.visitMethodInsn(<op:INVOKESPECIAL>, newObjClass, "<init>",
					"([Lorg/erights/e/elib/slot/Slot;[Ljava/lang/Object;)V");

				maxStack
			})
		}

		def evalAssign(noun, value) {
			switch (noun) {
				match lNoun :LocalFinalNounExpr {
					def i := lNoun.getIndex()
					#def valueStack := evalGuard(guard, value)
					def valueStack := eval(value)
					mw.visitInsn(<op:DUP>)
					mw.visitIntInsn(<op:ASTORE>, eLocalToJaveLocal(i))
					return valueStack
				}
				match oNoun :OuterNounExpr {
					def i := oNoun.getIndex()
					# push(this.context)
					mw.visitVarInsn(<op:ALOAD>, 0);
					mw.visitFieldInsn(<op:GETFIELD>, className, "outers", "[Lorg/erights/e/elib/slot/Slot;")
					mw.visitLdcInsn(i)
					# stack: array, i
					mw.visitInsn(<op:AALOAD>)
					def valueStack := eval(value)
					# stack: slot, value
					mw.visitInsn(<op:DUP_X1>)
					# stack: value, slot, value
					mw.visitMethodInsn(<op:INVOKEINTERFACE>, "org/erights/e/elib/slot/Slot", "put",
							"(Ljava/lang/Object;)V")

					return max(valueStack + 1, 3)
				}
			}
		}

		def evalSlotExpr(slotExpr) {
			#traceln(`evalSlotExpr($slotExpr :${slotExpr.getNoun().__getAllegedType()})`)
			return switch (slotExpr.getNoun()) {
				match oNoun :OuterNounExpr {
					def i := oNoun.getIndex()
					mw.visitVarInsn(<op:ALOAD>, 0);
					mw.visitFieldInsn(<op:GETFIELD>, className, "outers", "[Lorg/erights/e/elib/slot/Slot;")
					mw.visitLdcInsn(i)
					mw.visitInsn(<op:AALOAD>)
					return 2
				}
			}
		}

		return bind eval(item) {
			traceln(`eval: $item : ${item.__getAllegedType()}`)
			switch (item) {
				match x :SlotExpr {
					return evalSlotExpr(x)
				}
				match x :OuterNounExpr {
					def i := x.getIndex()
					mw.visitVarInsn(<op:ALOAD>, 0);
					mw.visitFieldInsn(<op:GETFIELD>, className, "outers", "[Lorg/erights/e/elib/slot/Slot;")
					mw.visitLdcInsn(i)
					mw.visitInsn(<op:AALOAD>)
					mw.visitMethodInsn(<op:INVOKEINTERFACE>, "org/erights/e/elib/slot/Slot", "get",
							"()Ljava/lang/Object;")
					return 2
				}
				match x :FrameFinalNounExpr {
					def i := x.getIndex()
					mw.visitVarInsn(<op:ALOAD>, 0);
					mw.visitFieldInsn(<op:GETFIELD>, className, "fields", "[Ljava/lang/Object;")
					mw.visitLdcInsn(i)
					mw.visitInsn(<op:AALOAD>)
					return 2
				}
				match x :LocalFinalNounExpr {
					def i := x.getIndex()
					mw.visitIntInsn(<op:ALOAD>, eLocalToJaveLocal(i))
					return 1
				}
				match x :LocalSlotNounExpr {
					def i := x.getIndex()
					mw.visitIntInsn(<op:ALOAD>, eLocalToJaveLocal(i))
					mw.visitMethodInsn(<op:INVOKEINTERFACE>, "org/erights/e/elib/slot/Slot", "get",
							"()Ljava/lang/Object;")
					return 1
				}
				match x :FrameSlotNounExpr {
					def i := x.getIndex()
					mw.visitVarInsn(<op:ALOAD>, 0);
					mw.visitFieldInsn(<op:GETFIELD>, className, "fields", "[Ljava/lang/Object;")
					mw.visitLdcInsn(i)
					mw.visitInsn(<op:AALOAD>)
					return 2
				}
				match x :LiteralExpr {
					switch (x.value()) {
						match i :int {
							return evalEInt(i)
						}
						match s :String {
							mw.visitLdcInsn(s)
							return 1
						}
					}
				}
				match x :ObjectExpr {
					return evalObjectDef(x)
				}
				match x :IfExpr {
					return evalIf(x)
				}
				match x :AssignExpr {
					return evalAssign(x.getNoun(), x.getRValue())
				}
				match x :SeqExpr {
					var maxStack := 0
					def last := x.subs().size() - 1
					for i => expr in x.subs() {
						def exprStack := eval(expr)
						if (exprStack > maxStack) {
							maxStack := exprStack
						}
						if (i != last) {
							mw.visitInsn(<op:POP>)
						}
					}
					return maxStack
				}
				match d : DefineExpr {
					require(d.getOptEjectorExpr() == null)
					def pattern := d.getPattern()
					def value := d.getRValue()
					traceln(`def $pattern (${pattern.__getAllegedType()})`)

					return evalDef(pattern, value)
				}
				match call :CallExpr {
					var maxStack := 0
					def recipient := call.recipient()
					maxStack := eval(recipient) + 2
					mw.visitLdcInsn(call.verb())

					mw.visitIntInsn(<op:BIPUSH>, call.args().size())
					mw.visitTypeInsn(<op:ANEWARRAY>, "java/lang/Object")
					# stack: recipient, verb, array
					for i => arg in call.args() {
						mw.visitInsn(<op:DUP>)
						mw.visitLdcInsn(i);
						# stack: recipient, verb, array, array, i
						def stackForArg := eval(arg) + 5
						mw.visitInsn(<op:AASTORE>)
						if (stackForArg > maxStack) {
							maxStack := stackForArg
						}
					}
					mw.visitMethodInsn(<op:INVOKESTATIC>, "org/erights/e/elib/prim/E", "callAll",
						"(Ljava/lang/Object;Ljava/lang/String;[Ljava/lang/Object;)Ljava/lang/Object;")
					return maxStack
				}
			}
		}
	}
}
