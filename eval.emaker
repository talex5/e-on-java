def ObjectExpr := <type:org.erights.e.elang.evm.ObjectExpr>
def FinalPattern := <type:org.erights.e.elang.evm.FinalPattern>
def SlotPattern := <type:org.erights.e.elang.evm.SlotPattern>
def VarPattern := <type:org.erights.e.elang.evm.VarPattern>
def OuterNounExpr := <type:org.erights.e.elang.evm.OuterNounExpr>
def SlotExpr := <type:org.erights.e.elang.evm.SlotExpr>
def LocalFinalNounExpr := <type:org.erights.e.elang.evm.LocalFinalNounExpr>
def LiteralExpr := <type:org.erights.e.elang.evm.LiteralExpr>
def CallExpr := <type:org.erights.e.elang.evm.CallExpr>
def SeqExpr := <type:org.erights.e.elang.evm.SeqExpr>
def AssignExpr := <type:org.erights.e.elang.evm.AssignExpr>
def DefineExpr := <type:org.erights.e.elang.evm.DefineExpr>
def IfExpr := <type:org.erights.e.elang.evm.IfExpr>
def FrameFinalNounExpr := <type:org.erights.e.elang.evm.FrameFinalNounExpr>
def LocalSlotNounExpr := <type:org.erights.e.elang.evm.LocalSlotNounExpr>
def FrameSlotNounExpr := <type:org.erights.e.elang.evm.FrameSlotNounExpr>
def FinallyExpr := <type:org.erights.e.elang.evm.FinallyExpr>
def EscapeExpr := <type:org.erights.e.elang.evm.EscapeExpr>

def max(a, b) {
	if (a > b) {
		return a
	} else {
		return b
	}
}

def makeMethodCompiler(<asm>, queueCompileInnerClass) {
	return def compile(mw, className :String) {
		def eval
		def evalRepresentation

		def makeLabel := <asm:makeLabel>
		def Opcodes := <asm:makeOpcodes>
		def <op> {
			to get(code) {
				return E.call(Opcodes, `get$code`, [])
			}
		}

		def evalGuard(guard, valueMaker) {
			if (guard == null) {
				return valueMaker()
			}

			#E.call(foo, "coerce", specimen, optEjector);
			def guardStack := eval(guard)
			mw.constant("coerce");
			valueMaker()
			mw.constant(null)	# XXX
			mw.invokeStatic("org/erights/e/elib/prim/E", "call",
				"(Ljava/lang/Object;Ljava/lang/String;Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;")
			#mw.visitMethodInsn(<op:INVOKEVIRTUAL>, "org/erights/e/elib/slot/Guard", "coerce",
			#"(Ljava/lang/Object;Lorg/erights;Lorg/erights/e/elib/util/OneArgFunc;)Ljava/lang/Object;")
		}

		# => slot, value
		def evalMakeSlot(pattern, valueMaker) {
			def guard := pattern.getOptGuardExpr()

			evalGuard(guard, valueMaker)

			if (pattern =~ sp :SlotPattern) {
				# The value is the slot
				mw.dup()
			}

			# Package top-most value in a slot
			def slotType := switch (pattern) {
				match finalPattern :FinalPattern {
					"org/erights/e/elib/slot/FinalSlot"
				}
				match varPattern :VarPattern {
					if (guard == null) {
						"org/erights/e/elib/slot/SimpleSlot"
					} else {
						"org/erights/e/elib/slot/SettableSlot"
					}
				}
			}

			mw.new(slotType)
			# stack: value, slot
			mw.swap()
			mw.dup2()
			# stack: slot, value, slot, value

			mw.invokeInit(slotType, "(Ljava/lang/Object;)V")

			# stack: slot, value
		}

		def evalEInt(value :int) {
			# XXX: values longer than Long?
			mw.constantLong(value)
			mw.invokeStatic("java/math/BigInteger", "valueOf", "(J)Ljava/math/BigInteger;")
			return 1
		}

		def evalIf(ifExpr) {
			eval(ifExpr.getTest())
			mw.invokeStatic("org/erights/e/elib/prim/E", "asBoolean",
				"(Ljava/lang/Object;)Z")

			mw.ifTrue(
				fn { eval(ifExpr.getThen()) },
				fn { eval(ifExpr.getElse()) }
			)
		}

		# Bind valueMaker() to pattern, calling ejector on failure.
		# If ejector is null, throw an exception on failure.
		# => ...
		# <= value
		def testMatch(pattern, valueMaker, ejector) {
			require(ejector == null)
			def guard := pattern.getOptGuardExpr()
			def noun := pattern.getNoun()
			traceln(`def $noun (${noun.__getAllegedType()})`)
			switch (noun) {
				match lsNoun :LocalSlotNounExpr {
					def i := lsNoun.getIndex()
					evalMakeSlot(pattern, valueMaker)
					mw.dupX1()
					mw.pop()
					# stack: value, slot
					mw.storeLocal(mw.eLocalToJaveLocal(i))
				}
				match lNoun :LocalFinalNounExpr {
					pattern :FinalPattern
					def i := lNoun.getIndex()
					evalGuard(guard, valueMaker)
					mw.dup()
					mw.storeLocal(mw.eLocalToJaveLocal(i))
				}
				match oNoun :OuterNounExpr {
					def i := oNoun.getIndex()
					# this.outers[i] := new Slot(value)
					mw.loadThis()
					mw.loadOurField("outers", "[Lorg/erights/e/elib/slot/Slot;")
					# stack: outers
					evalMakeSlot(pattern, valueMaker)
					# stack: outers, slot, value
					mw.dupX2()
					mw.pop()
					# stack: value, outers, slot
					mw.constant(i)
					mw.swap()
					# stack: value, outers, i, slot
					mw.storeToArray()
					# stack: value
				}
			}
		}

		def evalObjectDef(objExpr) {
			return testMatch(objExpr.getOName(), fn {
				def newObjClass := queueCompileInnerClass(objExpr)

				def oName := objExpr.getOName()

				mw.new(newObjClass)
				mw.dup()
				mw.loadThis()
				mw.loadOurField("outers", "[Lorg/erights/e/elib/slot/Slot;")

				# Create a new array for the fields (non-outer variables in scope of the object and
				# used inside the object).
				def fields := objExpr.optFieldNouns()
				mw.constant(fields.size())
				mw.newArray("java/lang/Object")
				# stack: object, context, array
				var maxStack := 4
				for i => field in fields {
					mw.dup()
					mw.constant(i);
					traceln(`field $i (${i.__getAllegedType()})`)
					# stack: object, context, array, array, i
					evalRepresentation(field)
					mw.storeToArray()
				}

				mw.invokeInit(newObjClass, "([Lorg/erights/e/elib/slot/Slot;[Ljava/lang/Object;)V");
			}, null)
		}

		# => slot
		def evalSlotExpr(noun) {
			#traceln(`evalSlotExpr($slotExpr :${slotExpr.getNoun().__getAllegedType()})`)
			return switch (noun) {
				match lNoun :LocalSlotNounExpr {
					mw.loadLocal(mw.eLocalToJaveLocal(lNoun.getIndex()))
				}
				match fNoun :FrameSlotNounExpr {
					def i := fNoun.getIndex()
					mw.loadThis()
					mw.loadOurField("fields", "[Ljava/lang/Object;")
					mw.constant(i)
					mw.loadFromArray()
				}
				match oNoun :OuterNounExpr {
					def i := oNoun.getIndex()
					mw.loadThis()
					mw.loadOurField("outers", "[Lorg/erights/e/elib/slot/Slot;")
					mw.constant(i)
					mw.loadFromArray()
				}
			}
		}

		# When copying into fields, sometimes we want the value, sometimes we want the slot.
		bind evalRepresentation(noun) {
			traceln(`noun: $noun : ${noun.__getAllegedType()}`)
			switch (noun) {
				match x :FrameFinalNounExpr {
					eval(x)
				}
				match x :LocalSlotNounExpr {
					evalSlotExpr(x)
				}
				match x :LocalFinalNounExpr {
					eval(x)
				}
			}
		}

		# Update an existing slot
		def evalAssign(assign) {
			def noun := assign.getNoun()
			def value := assign.getRValue()
			traceln(`$noun (${noun.__getAllegedType()})`)
			switch (noun) {
				match lNoun :LocalSlotNounExpr {
					evalSlotExpr(lNoun)
					eval(value)
					mw.dupX1()
					mw.invokeInterface("org/erights/e/elib/slot/Slot", "put",
							"(Ljava/lang/Object;)V")
				}
				match lNoun :LocalFinalNounExpr {
					def i := lNoun.getIndex()
					#def valueStack := evalGuard(guard, value)
					eval(value)
					mw.dup()
					mw.storeLocal(<op:ASTORE>, mw.eLocalToJaveLocal(i))
				}
				match fNoun :FrameSlotNounExpr {
					evalSlotExpr(fNoun)
					eval(value)
					mw.dupX1()
					mw.invokeInterface("org/erights/e/elib/slot/Slot", "put",
							"(Ljava/lang/Object;)V")
				}
				match oNoun :OuterNounExpr {
					def i := oNoun.getIndex()
					# push(this.context)
					mw.loadThis()
					mw.loadOurField("outers", "[Lorg/erights/e/elib/slot/Slot;")
					mw.constant(i)
					# stack: array, i
					mw.loadFromArray()
					eval(value)
					# stack: slot, value
					mw.dupX1()
					# stack: value, slot, value
					mw.invokeInterface("org/erights/e/elib/slot/Slot", "put",
							"(Ljava/lang/Object;)V")
				}
			}
		}

		def evalFinally(finallyExpr) {
			# try {
			# startAttempt:
			#   attempt()
			# endAttempt:
			#   jsr finally
			#   goto done
			# } catch _ {
			# catchBlock:
			#   jsr finally
			#   rethrow
			# }
			# finally:
			#   unwinder()
			#   ret
			# done:

			mw.tryFinally(fn {
				eval(finallyExpr.getAttempt())
			}, fn {
				eval(finallyExpr.getUnwinder())
				mw.pop()
			})
		}

		def evalEscape(escapeExpr) {
			# ejectorTmp = new Ejector()
			# try {
			# startAttempt:
			#   def ejector := ejectorTmp
			#   attempt()
			# endAttempt:
			#   ejectorTmp.disable()
			#   goto done
			# } catch ex {
			# catchBlock:
			#   ejectorTmp.disable()
			#   result := ejectorTmp.result(ex)	# Rethrows if not ours
			#   (bind to arg and run catch block, if any)
			#   }
			# }
			# done:
			def startAttempt := makeLabel()
			def endAttempt := makeLabel()
			def catchBlock := makeLabel()
			def done := makeLabel()

			require(escapeExpr.getOptCatcher() == null)

			var name := escapeExpr.getExitPatt().getOptName()
			if (name == null) {
				name := "escape-expr"
			}

			mw.visitTypeInsn(<op:NEW>, "org/erights/e/elib/base/Ejector")
			def ejectorVar := mw.allocLocal()
			mw.visitInsn(<op:DUP>)
			mw.constant(name)
			mw.visitMethodInsn(<op:INVOKESPECIAL>, "org/erights/e/elib/base/Ejector", "<init>",
					"(Ljava/lang/String;)V")
			mw.visitIntInsn(<op:ASTORE>, ejectorVar)

			mw.visitLabel(startAttempt)
			def bindEjectorStack := testMatch(escapeExpr.getExitPatt(), fn {
				mw.visitIntInsn(<op:ALOAD>, ejectorVar)
				1
			}, null)
			mw.visitInsn(<op:POP>)
			def attemptStack := max(bindEjectorStack, eval(escapeExpr.getRValue()))
			mw.visitLabel(endAttempt)
			# stack: value

			mw.visitIntInsn(<op:ALOAD>, ejectorVar)
			mw.visitMethodInsn(<op:INVOKEVIRTUAL>, "org/erights/e/elib/base/Ejector", "disable", "()V")

			mw.visitJumpInsn(<op:GOTO>, done)

			# Catch block
			mw.visitLabel(catchBlock)

			# stack: exception

			mw.visitIntInsn(<op:ALOAD>, ejectorVar)
			mw.visitInsn(<op:DUP>)
			# stack: exception, ejector, ejector
			mw.visitMethodInsn(<op:INVOKEVIRTUAL>, "org/erights/e/elib/base/Ejector", "disable", "()V")
			# stack: exception, ejector
			mw.visitInsn(<op:SWAP>)
			mw.visitMethodInsn(<op:INVOKEVIRTUAL>, "org/erights/e/elib/base/Ejector", "result", "(Ljava/lang/Throwable;)Ljava/lang/Object;")
			# stack: result

			def catcherStack := 2
			#def catcherStack := eval(escapeExpr.getOptCatcher()) + 2	# XXX

			mw.visitLabel(done)
			# stack: result

			# XXX: check nesting. The JVM uses the first matching handler in the table.
			mw.visitTryCatchBlock(startAttempt, endAttempt, catchBlock, null)

			mw.releaseVar(ejectorVar)

			return max(attemptStack, catcherStack)
		}

		# Stack must be empty, because some constructs throw and catch exceptions and that clears the stack.
		bind eval(item) {
			traceln(`eval: $item : ${item.__getAllegedType()}`)
			switch (item) {
				match x :SlotExpr {
					evalSlotExpr(x.getNoun())
				}
				match x :OuterNounExpr {
					def i := x.getIndex()
					mw.loadThis()
					mw.loadOurField("outers", "[Lorg/erights/e/elib/slot/Slot;")
					mw.constant(i)
					mw.loadFromArray()
					mw.invokeInterface("org/erights/e/elib/slot/Slot", "get", "()Ljava/lang/Object;")
				}
				match x :FrameFinalNounExpr {
					def i := x.getIndex()
					mw.loadThis()
					mw.loadOurField("fields", "[Ljava/lang/Object;")
					mw.constant(i)
					mw.loadFromArray()
				}
				match x :LocalFinalNounExpr {
					def i := x.getIndex()
					mw.loadLocal(mw.eLocalToJaveLocal(i))
				}
				match x :LocalSlotNounExpr {
					def i := x.getIndex()
					mw.loadLocal(mw.eLocalToJaveLocal(i))
					mw.invokeInterface("org/erights/e/elib/slot/Slot", "get",
							"()Ljava/lang/Object;")
				}
				match x :FinallyExpr {
					return evalFinally(x)
				}
				match x :FrameSlotNounExpr {
					def i := x.getIndex()
					mw.loadThis()
					mw.loadOurField("fields", "[Ljava/lang/Object;")
					mw.constant(i)
					mw.loadFromArray()
					mw.invokeInterface("org/erights/e/elib/slot/Slot", "get",
							"()Ljava/lang/Object;")
				}
				match x :LiteralExpr {
					switch (x.value()) {
						match i :int {
							return evalEInt(i)
						}
						match s :String {
							mw.constant(s)
							return 1
						}
					}
				}
				match x :ObjectExpr {
					return evalObjectDef(x)
				}
				match x :IfExpr {
					return evalIf(x)
				}
				match x :AssignExpr {
					evalAssign(x)
				}
				match x :SeqExpr {
					var maxStack := 0
					def last := x.subs().size() - 1
					for i => expr in x.subs() {
						eval(expr)
						if (i != last) {
							mw.pop()
						}
					}
					return maxStack
				}
				match x :EscapeExpr {
					return evalEscape(x)
				}
				match d :DefineExpr {
					require(d.getOptEjectorExpr() == null)
					def pattern := d.getPattern()
					def value := d.getRValue()
					return testMatch(pattern, fn {eval(value)}, null)
				}
				match call :CallExpr {
					def recipient := call.recipient()
					eval(recipient)
					mw.constant(call.verb())

					mw.constant(call.args().size())
					mw.newArray("java/lang/Object")
					# stack: recipient, verb, array
					for i => arg in call.args() {
						mw.dup()
						mw.constant(i)
						# stack: recipient, verb, array, array, i
						eval(arg)
						mw.storeToArray()
					}
					mw.invokeStatic("org/erights/e/elib/prim/E", "callAll",
						"(Ljava/lang/Object;Ljava/lang/String;[Ljava/lang/Object;)Ljava/lang/Object;")
				}
			}
		}

		return def compiler {
			to run(code) {
				return eval(code)
			}
		}
	}
}
