package org.erights.e.elang.interp;

/*
The contents of this file are subject to the Electric Communities E Open
Source Code License Version 1.0 (the "License"); you may not use this file
except in compliance with the License. You may obtain a copy of the License
at http://www.communities.com/EL/.

Software distributed under the License is distributed on an "AS IS" basis,
WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License for
the specific language governing rights and limitations under the License.

The Original Code is the Distributed E Language Implementation, released
July 20, 1998.

The Initial Developer of the Original Code is Electric Communities.
Copyright (C) 1998 Electric Communities. All Rights Reserved.

Contributor(s): ______________________________________.
*/

import org.erights.e.develop.assertion.T;
import org.erights.e.elang.evm.BaseEvaluator;
import org.erights.e.elang.scope.Scope;
import org.erights.e.elang.syntax.ENodeBuilder;
import org.erights.e.elang.syntax.EParser;
import org.erights.e.elib.base.ClassDesc;
import org.erights.e.elib.base.MessageDesc;
import org.erights.e.elib.base.ParamDesc;
import org.erights.e.elib.base.SourceSpan;
import org.erights.e.elib.debug.Traceln;
import org.erights.e.elib.eio.EIO;
import org.erights.e.elib.oldeio.TextWriter;
import org.erights.e.elib.prim.E;
import org.erights.e.elib.prim.StaticMaker;
import org.erights.e.elib.prim.Thrower;
import org.erights.e.elib.ref.Ref;
import org.erights.e.elib.ref.Resolver;
import org.erights.e.elib.serial.DeepFrozenAuditor;
import org.erights.e.elib.serial.DeepPassByCopyAuditor;
import org.erights.e.elib.serial.Loader;
import org.erights.e.elib.serial.PassByConstructionAuditor;
import org.erights.e.elib.serial.PassByCopyAuditor;
import org.erights.e.elib.serial.PersistentAuditor;
import org.erights.e.elib.slot.AnyGuard;
import org.erights.e.elib.slot.AuditChecker;
import org.erights.e.elib.slot.FinalSlot;
import org.erights.e.elib.slot.Guard;
import org.erights.e.elib.slot.ListGuard;
import org.erights.e.elib.slot.MapGuard;
import org.erights.e.elib.slot.NullOkGuard;
import org.erights.e.elib.slot.SetGuard;
import org.erights.e.elib.slot.TupleGuard;
import org.erights.e.elib.slot.VoidGuard;
import org.erights.e.elib.tables.ConstList;
import org.erights.e.elib.tables.ConstMap;
import org.erights.e.elib.tables.ConstSet;
import org.erights.e.elib.tables.Equalizer;
import org.erights.e.elib.tables.Twine;
import org.erights.e.elib.util.ClassCache;
import org.erights.e.elib.util.IdentityFunc;
import org.erights.e.elib.vat.Vat;
import org.erights.e.meta.java.io.FileGetter;
import org.quasiliteral.quasiterm.QBuilder;
import org.quasiliteral.text.SimpleQuasiParser;

/**
 * The initial namespaces seen by the E language programmer.
 *
 * @author Mark S. Miller
 * @author E. Dean Tribble
 */
public final class ScopeSetup {

    /**
     * prevent instantiation
     */
    private ScopeSetup() {
    }

    // number of spaces to leave for more outers.
    static final int OUTER_SPACE = 1000;

    /**
     * Return the set of variable names defined in the safe scope that may not
     * be shadowed (ie, redefined).
     * <p/>
     * This currently includes all names in the safeScope, but should only
     * include those names generated by the {@link ENodeBuilder E expansion}
     * and a few others, as explained in the source code in this class.
     */
    static public final ConstSet NonShadowable;

    static {
        Object[] safePair =
          safeScopePair("__NonShadowable$");
        NonShadowable = ((ScopeMaker)safePair[0]).getVarNames();
    }

    /**
     * return null if not found
     */
    static private Class getClass(String fqName) {
        try {
            return ClassCache.forName(fqName);
        } catch (ClassNotFoundException cnfe) {
            return null;
        }
    }

    /**
     *
     *
     */
    static private ScopeMaker universalMaker(Ref safeScopeVow) {

        ScopeMaker um = new ScopeMaker();

        /*
         * The E expansion generates references to the following.
         * <p>
         * Since these are referenced by expansion, and we don't (yet?) have
         * hygenic syntactic scopes, the following names are unshadowable.
         */

        um.comp("null", null);
        um.comp("false", Boolean.FALSE);
        um.comp("true", Boolean.TRUE);

        um.comp("throw", Thrower.THE_ONE);
        um.comp("__loop", Loop.THE_ONE);
        um.comp("__makeList", ConstList.GetMaker());
        um.comp("__makeMap", ConstMap.GetMaker());
        um.comp("__makeProtocolDesc", ProtocolDesc.ProtocolDescMaker);
        um.comp("__makeMessageDesc", MessageDesc.GetMessageDescMaker());
        um.comp("__makeParamDesc", ParamDesc.GetParamDescMaker());

        um.comp("any", AnyGuard.THE_ONE);
        um.comp("void", VoidGuard.THE_ONE);

        um.comp("boolean", ClassDesc.make(Boolean.class));
        um.comp("__makeOrderedSpace",
                safeScopeVow,
                "<elang:coord.OrderedSpaceMaker>");

        um.comp("Guard", ClassDesc.make(Guard.class));

        um.comp("require", safeScopeVow, "<elang:interp.require>");

        um.comp("__makeVerbFacet",
                safeScopeVow,
                "<elang:expand.__makeVerbFacet>");

        um.comp("__MatchContext",
                safeScopeVow,
                "<elang:expand.__MatchContext>");
        um.comp("__is", safeScopeVow, "<elang:expand.__is>");
        um.comp("__splitList", safeScopeVow, "<elang:expand.__splitList>");
        um.comp("__suchThat", safeScopeVow, "<elang:expand.__suchThat>");
        um.comp("__bind", safeScopeVow, "<elang:expand.__bind>");
        um.comp("__extract", safeScopeVow, "<elang:expand.__extract>");
        um.comp("__Empty", safeScopeVow, "<elang:expand.__Empty>");
        um.comp("__matchBind", safeScopeVow, "<elang:expand.__matchBind>");
        um.comp("__Test", safeScopeVow, "<elang:expand.__Test>");

        /*
         * References to the following are not currently generated by the E
         * expansion, but they are the remaining variable names (in addition
         * to null, false, and true) used to "literally enough" write those
         * scalars values that can't be written as literals in E. A LiteralExpr
         * is sometimes programmatically constructed to hold such a value.
         * Such a LiteralExpr will print as "NaN or "Infinity". So these need
         * to be unshadowable in order for the LiteralExpr's printed form to
         * necessarily evaluate to the same value.
         */
        um.comp("NaN", new Double(Double.NaN));
        um.comp("Infinity", new Double(Double.POSITIVE_INFINITY));

        /*
         * References to the following are not currently generated by the E
         * expansion, but these should remain unshadowable anyway because of
         * their use in Data-E serialization/unserialization.
         */
        um.comp("__identityFunc", IdentityFunc.THE_ONE);
        um.comp("__makeInt",
                safeScopeVow,
                "<import:org.erights.e.meta.java.math.makeEInt>");

        /*
         * References to the following are not currently generated by the E
         * expansion, but may be in the future. So these must be unshadowable
         * until we decide. Note that "when" is absent from this list, but
         * appears in another list below.
         */
        um.comp("escape", safeScopeVow, "<elang:control.escape>");
        um.comp("for", safeScopeVow, "<elang:control.for>");
        um.comp("if", safeScopeVow, "<elang:control.if>");
        um.comp("try", safeScopeVow, "<elang:control.try>");
        um.comp("while", safeScopeVow, "<elang:control.while>");


        um.comp("__makeFinalSlot", FinalSlot.FinalSlotMaker);

        um.comp("__makeTwine", Twine.GetTwineMaker());
        um.comp("__makeSourceSpan", SourceSpan.SourceSpanMaker);

        um.comp("__auditedBy", AuditChecker.THE_ONE);
        um.comp("near", safeScopeVow, "<elib:slot.near>");
        um.comp("pbc", PassByConstructionAuditor.THE_ONE);
        um.comp("PassByCopy", PassByCopyAuditor.THE_ONE);
        um.comp("DeepPassByCopy", DeepPassByCopyAuditor.THE_ONE);
        um.comp("Data", DeepPassByCopyAuditor.THE_ONE);
        um.comp("Persistent", PersistentAuditor.THE_ONE);
        um.comp("DeepFrozen", DeepFrozenAuditor.THE_ONE);

        um.comp("int",
                safeScopeVow,
                "__makeOrderedSpace(" +
                  "<type:org.erights.e.meta.java.math.EInt>, \"int\")");
        um.comp("float64",
                safeScopeVow,
                "__makeOrderedSpace(" +
                  "<import:java.lang.makeDouble>.getTYPE(), \"float64\")");
        um.comp("char",
                safeScopeVow,
                "__makeOrderedSpace(" +
                  "<import:java.lang.makeCharacter>.getTYPE(), \"char\")");

        um.comp("String", ClassDesc.make(String.class));
        um.comp("Twine", ClassDesc.make(Twine.class));
        um.comp("TextWriter", ClassDesc.make(TextWriter.class));

        /*
         * References to the following are not generated by the E expansion,
         * and probably won't be, so these should be made shadowable. As of
         * this writing, XXX they are still unshadowable.
         */

        um.comp("List", ListGuard.THE_BASE);
        um.comp("Map", MapGuard.THE_BASE);
        um.comp("Set", SetGuard.THE_BASE);
        um.comp("nullOk", NullOkGuard.THE_BASE);
        um.comp("Tuple", TupleGuard.TupleGuardMaker);
        um.comp("__Portrayal", safeScopeVow, "Tuple[any, String, List[any]]");

        um.comp("notNull", safeScopeVow, "<elang:interp.notNull>");
        um.comp("vow", safeScopeVow, "<elang:interp.vow>");
        um.comp("rcvr", safeScopeVow, "<elang:interp.rcvr>"); // deprecated
        um.comp("ref", Ref.broken(E.asRTE("'ref' is currently reserved.")));
        um.comp("nocall",
                Ref.broken(E.asRTE("'nocall' is currently reserved.")));
        um.comp("SturdyRef", safeScopeVow, "<type:net.captp.jcomm.SturdyRef>");

        um.comp("simple__quasiParser", SimpleQuasiParser.THE_ONE);
        um.comp("twine__quasiParser",
                safeScopeVow,
                "<import:org.quasiliteral.text.twine__quasiParser>");
        um.comp("rx__quasiParser",
                safeScopeVow,
                "<elang:interp.makePerlMatchMaker>");
        // olde`..` is deprecated. Use e`..`
        um.comp("olde__quasiParser", EParser.EParserMaker);
        um.comp("e__quasiParser", EParser.EParserMaker);
        um.comp("epatt__quasiParser",
                safeScopeVow,
                "<elang:syntax.epatt__quasiParser>");
        um.comp("sml__quasiParser",
                safeScopeVow,
                "<import:org.capml.quasi.makeXMLQuasiParser>");
        um.comp("term__quasiParser", QBuilder.term__quasiParser);

        return um;
    }

    /**
     *
     */
    static private ScopeMaker safeMakerBase(Ref safeScopeVow) {

        ScopeMaker sm = universalMaker(safeScopeVow).copy();

        /*
         * The E expansion generates references to these, so they are
         * unshadowable. These perhaps should also be promoted into the
         * universalScope.
         */

        sm.init("__equalizer", Equalizer.make());           // not uconstant?
        sm.init("__comparer", Comparer.THE_ONE);            // not uconstant?
        sm.init("Ref", Ref.GetRefMaker());                  // not uconstant??

        /*
         * The E expansion generates references to these, so they are
         * unshadowable.
         */

        sm.init("E",
                safeScopeVow,
                "<elang:interp.makeE4E>");                  // not uconstant
        sm.init("promiseAllFulfilled",
                safeScopeVow,
                "<elang:interp.promiseAllFulfilled>");      // not uconstant

        /*
         * References to the following are not generated by the E expansion,
         * and probably won't be, so these should be made shadowable. As of
         * this writing, XXX they are still unshadowable.
         */

        sm.init("EIO", EIO.EIOMaker);
        sm.init("help", new Help());                        // not uconstant?
        sm.init("safeScope", safeScopeVow);                 // not uconstant

        sm.init("__eval", BaseEvaluator.THE_ONE);

        sm.init("resource__uriGetter",
                ResourceUriGetter.THE_ONE);                 // not uconstant!!
        sm.init("type__uriGetter", TypeLoader.THE_ONE);     // not uconstant
        sm.init("elib__uriGetter", safeScopeVow, // not uconstant!!
                "<import:org.erights.e.elib.*>");
        sm.init("elang__uriGetter", safeScopeVow, // not uconstant!!
                "<import:org.erights.e.elang.*>");
        sm.init("opaque__uriGetter", safeScopeVow, // not uconstant?
                "<elib:serial.opaque__uriGetter>");

        String problemStr = "XXX __abortIncarnation not yet implemented";
        sm.init("__abortIncarnation", Ref.broken(E.asRTE(problemStr)));

        sm.init("when", safeScopeVow, "<elang:control.when>");

        return sm;
    }


    /**
     * Returns a fresh instantiation of the safe scope. This scope contains
     * only transitively immutable objects, or objects like the importer (bound
     * to "&lt;import&gt;") with transparent-enough caches. It conveys no
     * substantial authority, and so can be given out freely.
     */
    static private Scope safeScope(String fqnPrefix) {
        return (Scope)safeScopePair(fqnPrefix)[1];
    }

    /**
     * Makes a [ScopeMaker,Scope] pair representing a safeScope, with the
     * provided loader as its "&lt;import&gt;".
     */
    static Object[] safeScopePair(String fqnPrefix) {
//        Exception ex = new RuntimeException("safeScopePair");
//        ex.fillInStackTrace();
//        System.out.println("NEW safeScopePair in " + Thread.currentThread());
//        ex.printStackTrace();

        // def safeScope
        Object[] promise = Ref.promise();
        Ref safeScopeVow = (Ref)promise[0];
        Resolver safeScopeResolver = (Resolver)promise[1];

        ScopeMaker sm = safeMakerBase(safeScopeVow).copy();

        Object[] importLoaderPair = Ref.promise();
        sm.init("import__uriGetter", importLoaderPair[0]);   // not uconstant

        T.require(fqnPrefix.endsWith(".") || fqnPrefix.endsWith("$"),
                  "fqnPrefix must end with '.' or '$': ",
                  fqnPrefix);
        String fqName = fqnPrefix.substring(0, fqnPrefix.length() - 1);
        sm.init("traceln", new Traceln(fqName));

        Scope safeScope = sm.make(fqnPrefix);
        safeScopeResolver.resolve(safeScope);
        ((Resolver) importLoaderPair[1]).resolve(new ImportLoader(safeScope));
        Object[] result = {sm, safeScope};
        return result;
    }


    /**
     * @deprecated Use privileged/5
     */
    static public Scope privileged(String fqnPrefix,
                                   TextWriter altout,
                                   TextWriter alterr,
                                   CmdLoop interp) {
        return privileged(fqnPrefix,
                          Ref.broken(E.asRTE("XXX No stdin 5")),
                          altout,
                          alterr,
                          interp.getProps(),
                          interp,
                          null);
    }

    /**
     * Returns a fresh instantiation of the privileged scope.
     * <p/>
     * This scope contains the root magic powers, so should only be given to
     * fully trusted entities.
     */
    static public Scope privileged(String fqnPrefix,
                                   Ref altin,
                                   TextWriter altout,
                                   TextWriter alterr,
                                   CmdLoop interp) {
        return privileged(fqnPrefix,
                          altin,
                          altout,
                          alterr,
                          interp.getProps(),
                          interp,
                          null);
    }

    /**
     * @deprecated Use privileged/7
     */
    static public Scope privileged(String fqnPrefix,
                                   TextWriter altout,
                                   TextWriter alterr,
                                   ConstMap props,
                                   Object interpVow,
                                   Vat optVat) {
        return privileged(fqnPrefix,
                          Ref.broken(E.asRTE("XXX No stdin 6")),
                          altout,
                          alterr,
                          props,
                          interpVow,
                          optVat);
    }

    /**
     * If the interp isn't resolved yet, the props and vat must be provided
     * explicitly.
     *
     * @param optVat If null, uses the current vat.
     */
    static public Scope privileged(String fqnPrefix,
                                   Ref altin,
                                   TextWriter altout,
                                   TextWriter alterr,
                                   ConstMap props,
                                   Object interpVow,
                                   Vat optVat) {
        if (null == optVat) {
            optVat = Vat.getCurrentVat();
        }
        // XXX need some decent way to handle magic powers.
        StaticMaker entropyMaker =
          StaticMaker.make(getClass("net.vattp.security.ESecureRandom"));
        Object optEntropy = E.call(entropyMaker, "getESecureRandom");
        StaticMaker timerMaker =
          StaticMaker.make(getClass("org.erights.e.extern.timer.Timer"));
        Object optTimer = E.call(timerMaker, "theTimer");

        Object optIntroducer = null;
        Object optIdentityMgr = null;

        Class optIntroducerClass = getClass("net.captp.jcomm.Introducer");
        if (null == optIntroducerClass) {
            //We're space-time-local. Leave the above magic powers as null
        } else {
            //We're distributed. Obtain the powers.
            StaticMaker introMaker = StaticMaker.make(optIntroducerClass);
            Object[] pair = (Object[])E.call(introMaker,
                                             "makePair",
                                             props,
                                             optEntropy,
                                             optTimer);
            optIntroducer = pair[0];
            optIdentityMgr = pair[1];
        }

        Object[] promise = Ref.promise();
        Ref privScopeVow = (Ref)promise[0];
        Resolver privResolver = (Resolver)promise[1];

        Object[] safePair = safeScopePair(fqnPrefix);
        ScopeMaker pm = ((ScopeMaker)safePair[0]).copy();

        pm.init("file__uriGetter", FileGetter.THE_ONE);
        pm.init("fileURL__uriGetter", new URLGetter("file"));
        pm.init("jar__uriGetter", new URLGetter("jar"));
        pm.init("http__uriGetter", new URLGetter("http"));
        pm.init("ftp__uriGetter", new URLGetter("ftp"));
        pm.init("gopher__uriGetter", new URLGetter("gopher"));
        pm.init("news__uriGetter", new URLGetter("news"));
        pm.init("captp__uriGetter", optIntroducer);

        pm.init("makeCommand",
                privScopeVow,
                "<elib:extern.CommandMakerAuthor>(" +
                  "<unsafe:java.lang.makeRuntime>.getRuntime())");

        pm.init("stdout", altout);
        pm.init("stderr", alterr);
        pm.init("stdin", altin);
        pm.init("print",
                privScopeVow,
                "{def print {\n" + "    match [`run`, args] {\n" +
                  "        stdout.printAll(args)\n" + "    }\n" +
                  "    match [`__respondsTo`, [`run`, _]] { true }\n" + "}}");
        pm.init("println",
                privScopeVow,
                "{def println {\n" + "    match [`run`, args] {\n" +
                  "        stdout.printAll(args)\n" +
                  "        stdout.println()\n" + "    }\n" +
                  "    match [`__respondsTo`, [`run`, _]] { true }\n" + "}}");
        pm.init("interp", interpVow);

        pm.init("entropy", optEntropy);
        pm.init("timer", optTimer);
        pm.init("introducer", optIntroducer);
        pm.init("identityMgr", optIdentityMgr);

        if (null == optIntroducerClass) {
            //If we're space-local (non-distributed), then we're time-local as
            //well.
            pm.init("makeSturdyRef", null);
            pm.init("timeMachine", null);
        } else {
            //If we're distributed, then we might be persistent.
            pm.init("makeSturdyRef",
                    privScopeVow,
                    "<unsafe:org.erights.e.extern.persist.makeSturdyRefMaker>(\n" +
                      "    introducer, timer, identityMgr)");
            pm.init("timeMachine",
                    privScopeVow,
                    "{def initTimeMachine := \n" +
                      "  <import:org.erights.e.extern.persist.initTimeMachine>\n" +
                      " initTimeMachine(privilegedScope)\n" + "}");
        }

        //XXX swing: and awt: are still importable through unsafe:, even when
        //the runnerKind isn't "awt". This needs to be fixed or something.
        //Likewise with swt:
        pm.init("unsafe__uriGetter", UnsafeLoader.THE_ONE);

        pm.init("currentVat", optVat);

        String runeName = "<elang:cmd.runeAuthor>";
        pm.init("rune",
                privScopeVow,
                runeName + "([\"metaout\" => stdout,\n" +
                  "\"metaerr\" => stderr,\n" +
                  "\"defaultProps\" => interp.getProps()] |\n" + runeName +
                  ".defaultAuths(<unsafe>))");

        //not valid until we're in an awt Runner
        pm.init("awt__uriGetter",
                privScopeVow,
                "currentVat.requireKind(\"awt\")\n" + "<unsafe:java.awt.*>");
        pm.init("swing__uriGetter",
                privScopeVow,
                "currentVat.requireKind(\"awt\")\n" +
                  "<unsafe:javax.swing.*>");
        pm.init("JPanel__quasiParser",
                privScopeVow,
                "currentVat.requireKind(\"awt\")\n" +
                  "<import:org.erights.ex.swing.JPanel__quasiParser>");

        //not valid until we're in an swt Runner
        pm.init("swt__uriGetter",
                privScopeVow,
                "currentVat.requireKind(\"swt\")\n" +
                  "<unsafe:org.eclipse.swt.*>");
        //XXX should eventually accommodate multiple Displays, one per
        //SWTRunner.
        pm.init("currentDisplay",
                privScopeVow,
                "currentVat.requireKind(\"swt\")\n" +
                  "<swt:widgets.makeDisplay>.getDefault()");
        pm.init("swtGrid__quasiParser",
                privScopeVow,
                "currentVat.requireKind(\"swt\")\n" +
                  "<import:org.erights.e.ui.swt.swtGridQParserMaker>()");
        pm.init("swtWatch",
                privScopeVow,
                "currentVat.requireKind(\"swt\")\n" +
                  "<import:org.erights.e.ui.swt.watchAuthor>(\n" +
                  "    <swt>,\n" + "    currentDisplay,\n" + "    <file>,\n" +
                  "    timer,\n" + "    introducer,\n" + "    makeSturdyRef)");

        pm.init("privilegedScope", privScopeVow);
        Scope privScope = pm.make(fqnPrefix);
        privResolver.resolve(privScope);
        return privScope;
    }
}
