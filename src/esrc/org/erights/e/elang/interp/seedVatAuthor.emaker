#!/usr/bin/env rune

pragma.syntax("0.8")

# Copyright 2002 Combex, Inc. under the terms of the MIT X license
# found at http://www.opensource.org/licenses/mit-license.html ................

def Vat := <type:org.erights.e.elib.vat.Vat>
def runeAuthor := <elang:cmd.runeAuthor>

/**
 *
 */
def virtualSeedVatAuthor(makeVat, seedVat, introducer) :near {

    def virtualSeedVat {

        /**
         * Like seedVat.run/2, but returns a CapTP ref rather than a
         * boot-comm ref.
         */
        to run(vat :Vat, privSrc :String) :rcvr {
            def starter := seedVat <- run(vat, `
                def eParser := <elang:syntax.makeEParser>
                introducer.onTheAir()
                def starter {
                    to start(privSrc :String) :String {
                        def privExpr := eParser(privSrc)
                        def result := privExpr.eval(privilegedScope)
                        def sr := makeSturdyRef.temp(result)
                        return introducer.sturdyToURI(sr)
                    }
                }
            `)
            def uriVow := starter <- start(privSrc)
            def sturdyVow := when (uriVow) -> done(uri :String) :SturdyRef {
                return introducer.sturdyFromURI(uri)
            } catch problem {
                throw(problem)
            }
            return sturdyVow <- getRcvr()
        }

        /**
         * Like run/2, but makes and returns a fresh vat.
         */
        to run(privSrc :String) :Tuple[rcvr, Vat] {
            def vat := makeVat.make("headless", "newVirtualSeedVat")
            return [virtualSeedVat(vat, privSrc), vat]
        }
    }
    return virtualSeedVat
}


/**
 * Makes a seedVat function, for seeding vats in a thread-safe manner
 *
 * @author Mark S. Miller
 */
def seedVatAuthor(<unsafe>) :near {

    def makeVat := <unsafe:org.erights.e.elib.vat.makeVat>
    def makeVatSeeder := <unsafe:org.erights.e.elang.interp.makeVatSeeder>

    def seedVat {

        /**
         * Evaluates privSrc in a new privileged scope in the given vat.
         * <p>
         * The privSrc is evaluated as a single expression, not as a series of
         * expressions. The <tt>interp</tt> it has in scope responds only to
         * the getProps() message.
         * <p>
         * If thisDir is not null, <this> is added to the top-level scope,
         * allowing emakers to be imported from this directory.
         *
         * @return A remote promise for the value of the expression.
         *         This promise is an inter-vat reference using the
         *         boot-comm-system. Therefore, the value should either be
         *         PassByProxy or DeepPassByCopy, or an error will result in
         *         trying to resolve the promise.
         */
        to run(vat :Vat, privSrc :String, thisDir :nullOk[near]) :rcvr {
            def bootstrapCode := `
                def eval(privSrc :String, thisPath :nullOk[String]) {
                    def eParser := <elang:syntax.makeEParser>
                    def runeAuthor := <elang:cmd.runeAuthor>
                    def auths := runeAuthor.defaultAuths(<unsafe>)
                    def makeScopeSetup :=
                      <unsafe:org.erights.e.elang.interp.makeScopeSetup>

                    var privScope := makeScopeSetup.privileged("__main$$",
                                                               auths["metain"],
                                                               auths["metaout"],
                                                               auths["metaerr"],
                                                               interp.getProps(),
                                                               interp,
                                                               null)

                    if (thisPath != null) {
                        def makeTraceln := <unsafe:org.erights.e.elib.debug.makeTraceln>
                        def makeELoader := <elang:interp.ELoaderAuthor>(makeTraceln)
                        def <this> := makeELoader(<file>[thisPath], [ => <this> ], "__main$$")
                        privScope := privScope.with("this__uriGetter", <this>)
                    }

                    def privExpr := eParser(privSrc)
                    return privExpr.eval(privScope)
                }
            `
            def auths := runeAuthor.defaultAuths(<unsafe>)
            def eval := vat.seed(makeVatSeeder(bootstrapCode, auths["defaultProps"]))
            def thisPath := if (thisDir != null) {
                thisDir.getAbsolutePath()
            } else {
                null
            }
            return eval <- (privSrc, thisPath)
        }

        /** Like run/3, but with thisDir as null. */
        to run(vat :Vat, privSrc :String) :rcvr {
            return seedVat(vat, privSrc, null)
        }

        /**
         * Like run/2, but makes and returns a fresh vat.
         */
        to run(privSrc :String) :Tuple[rcvr, Vat] {
            def vat := makeVat.make("headless", "newSeedVat")
            return [seedVat(vat, privSrc, null), vat]
        }

        /**
         * Returns a virtualized seedVat function that acts like seedVat, but
         * returns remote CapTP references rather than remote boot-comm
         * references.
         * <p>
         * We should pass in our own introducer, which should be on the air
         * before run/1 or run/2 is called.
         */
        to virtualize(introducer) :near {
            return virtualSeedVatAuthor(makeVat, seedVat, introducer)
        }
    }
    return seedVat
}
