def writerAuthor(<asm>) {
	def makeLabel := <asm:makeLabel>
	def Opcodes := <asm:makeOpcodes>
	def <op> {
		to get(code) {
			return E.call(Opcodes, `get$code`, [])
		}
	}

	return def makeWriter(cw, className :String, flags, methodName :String, type :String, var nELocals) {
		var mw := cw.visitMethod(flags, methodName, type, null, null)

		if ((flags & <op:ACC_STATIC>) == 0) {
			nELocals += 1	# Allocate a local for "this"
		}

		var maxStackDepth := 0
		var stackDepth := 0

		var topUsedLocal := nELocals - 1
		var maxLocal := topUsedLocal

		def allocLocal() {
			topUsedLocal += 1
			if (topUsedLocal > maxLocal) {
				maxLocal := topUsedLocal
			}
			return topUsedLocal
		}

		def releaseVar(n :int) {
			require(n == topUsedLocal)
			topUsedLocal -= 1
		}

		def stack(n :int) {
			stackDepth += n
			require(stackDepth >= 0)
			if (stackDepth > maxStackDepth) {
				maxStackDepth := stackDepth
			}
		}

		def countArgs(sig) {
			def `(@args)@_` := sig
			var i:= 0
			var nArgs := 0

			while (i < args.size()) {
				if (args[i] != '[') {
					nArgs += 1
					if (args[i] == 'L') {
						i := args.indexOf1(';', i)
					}
				}
				i += 1
			}
			return nArgs
		}

		require(countArgs("(Ljava/lang/String;II)V") == 3)
		require(countArgs("([Ljava/lang/String;II)V") == 3)
		require(countArgs("()V") == 0)

		# Update stack for a call to type, ignoring "this"
		def stackFn(type :String) {
			stack(0 - countArgs(type))
			if (type =~ `@_)V`) {
				return
			}
			stack(1)	# The return value gets stacked
		}

		return def eMethodWriter {
			to eLocalToJaveLocal(i) {
				return i + 1
			}

			to constantLong(value) {
				mw.visitLdcInsn(value :<type:long>)
				stack(1)
			}

			to constant(value) {
				if (value =~ x :(int < 256)) {
					mw.visitIntInsn(<op:BIPUSH>, x)
				} else if (value == null) {
					mw.visitInsn(<op:ACONST_NULL>)
				} else {
					mw.visitLdcInsn(value)
				}
				stack(1)
			}

			to invokeStatic(klass, verb, type) {
				mw.visitMethodInsn(<op:INVOKESTATIC>, klass, verb, type)
				stackFn(type)
			}

			to invokeInit(targetClassName :String, type :String) {
				mw.visitMethodInsn(<op:INVOKESPECIAL>, targetClassName, "<init>", type)
				stackFn(type)
				stack(-1)
			}

			to loadThis() {
				eMethodWriter.loadLocal(0)
			}

			to loadOurField(fieldName :String, type :String) {
				eMethodWriter.loadField(className, fieldName, type)
			}

			to loadField(targetClassName :String, fieldName :String, type :String) {
				mw.visitFieldInsn(<op:GETFIELD>, targetClassName, fieldName, type)
			}

			to loadFromArray() {
				mw.visitInsn(<op:AALOAD>)
				stack(-1)	# array, index => value
			}

			to loadLocal(n :int) {
				mw.visitVarInsn(<op:ALOAD>, n)
				stack(1)
			}

			to storeLocal(n :int) {
				mw.visitVarInsn(<op:ASTORE>, n)
				stack(-1)
			}

			to invokeInterface(name :String, verb :String, type :String) {
				mw.visitMethodInsn(<op:INVOKEINTERFACE>, name, verb, type)
				stackFn(type)
				stack(-1)	# this
			}

			to new(type :String) {
				mw.visitTypeInsn(<op:NEW>, type)
				stack(1)
			}

			to newArray(type :String) {
				mw.visitTypeInsn(<op:ANEWARRAY>, type)
				# 0: nItems => array
			}

			to storeToArray() {
				mw.visitInsn(<op:AASTORE>)
				stack(-3)	# array, index, value
			}

			to dup() {
				mw.visitInsn(<op:DUP>)
				stack(1)
			}

			to dup2() {
				mw.visitInsn(<op:DUP2>)
				stack(2)
			}

			to pop() {
				mw.visitInsn(<op:POP>)
				stack(-1)
			}

			to swap() {
				mw.visitInsn(<op:SWAP>)
			}

			to dupX1() {
				mw.visitInsn(<op:DUP_X1>)
				stack(1)
			}

			to dupX2() {
				mw.visitInsn(<op:DUP_X2>)
				stack(1)
			}

			# Stack contains boolean.
			# If true, execute instructions generated by thenMaker()
			# If false, execute elseMaker()
			to ifTrue(thenMaker, elseMaker) {
				require(stackDepth == 1)

				def elseBlock := makeLabel()
				def done := makeLabel()

				mw.visitJumpInsn(<op:IFEQ>, elseBlock)
				stack(-1)
				def oldStack := stackDepth

				thenMaker()
				def thenStack := stackDepth
				mw.visitJumpInsn(<op:GOTO>, done)

				stackDepth := oldStack
				mw.visitLabel(elseBlock)
				elseMaker()
				def elseStack := stackDepth

				mw.visitLabel(done)

				require(thenStack == elseStack, `then stack gives $thenStack; else gives $elseStack)`)
			}

			to tryFinally(attemptMaker, finallyMaker) {
				def startAttempt := makeLabel()
				def endAttempt := makeLabel()
				def catchBlock := makeLabel()
				def finallyLabel := makeLabel()
				def done := makeLabel()

				mw.visitTryCatchBlock(startAttempt, endAttempt, catchBlock, null)

				require(stackDepth == 0, `stack is $stackDepth at start of try block`)

				mw.visitLabel(startAttempt)
				attemptMaker()
				mw.visitLabel(endAttempt)
				def attemptStack := stackDepth
				mw.visitJumpInsn(<op:JSR>, finallyLabel)
				mw.visitJumpInsn(<op:GOTO>, done)

				# Catch block
				stackDepth := 1		# the exception
				mw.visitLabel(catchBlock)
				def exVar := allocLocal()
				eMethodWriter.storeLocal(exVar)	# (must store the exception for type-checking)
				eMethodWriter.constant(null)		# (for consistent stack height)
				def catchStack := stackDepth
				mw.visitJumpInsn(<op:JSR>, finallyLabel)
				eMethodWriter.loadLocal(exVar)
				mw.visitInsn(<op:ATHROW>)

				# Finally
				require(catchStack == attemptStack, `attempt: $attemptStack, catch: $catchStack`)
				stackDepth := catchStack

				# stack: value, returnAddress
				mw.visitLabel(finallyLabel)

				finallyMaker()

				def tmp := allocLocal()
				eMethodWriter.storeLocal(tmp)
				mw.visitIntInsn(<op:RET>, tmp)

				mw.visitLabel(done)
				stackDepth := attemptStack

				releaseVar(tmp)
				releaseVar(exVar)
			}

			to endMethod() {
				traceln(`endMethod: ss = ${maxStackDepth}, locals = ${maxLocal + 1}`)
				mw.visitMaxs(maxStackDepth + 1, maxLocal + 1)
				mw.visitEnd()
				mw := null
			}

			to aReturn() {
				mw.visitInsn(<op:ARETURN>)
			}
		}
	}
}
