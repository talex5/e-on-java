def countArgs(sig) {
	def `(@args)@_` := sig
	var i:= 0
	var nArgs := 0

	while (i < args.size()) {
		if (args[i] != '[') {
			nArgs += 1
			if (args[i] == 'L') {
				i := args.indexOf1(';', i)
			}
		}
		i += 1
	}
	return nArgs
}

def returnType(type :String) {
	def `(@_)@rtype` := type
	return rtype
}

require(countArgs("(Ljava/lang/String;II)V") == 3)
require(countArgs("([Ljava/lang/String;II)V") == 3)
require(countArgs("()V") == 0)

def unifyBranchTypes(stackA, stackB) {
	require(stackA.size() == stackB.size(), `Different lengths: $stackA vs $stackB`)

	def result := [].diverge()
	for i => a in stackA {
		def b := stackB[i]
		if (a == b) {
			result.push(a)
		} else {
			require(a[0] == "L" && b[0] == "L")
			result.push("Ljava/lang/Object;")
		}
	}
	return result.snapshot()
}

def writerAuthor(<asm>, println) {
	def makeLabel := <asm:makeLabel>
	def Opcodes := <asm:makeOpcodes>
	def <op> {
		to get(code) {
			return E.call(Opcodes, `get$code`, [])
		}
	}

	return def makeWriter(cw, className :String, flags, methodName :String, type :String, nELocals :int) {
		def localType := [].asMap().diverge()	# int => Java type
		var stackType :List := []		# Java types

		localType[0] := `L$className;`	# this

		var nArgs := countArgs(type)

		# TODO: get from type
		for i in 0..nArgs {
			localType[i + 1] := "Ljava/lang/Object;"
		}

		var mw := cw.visitMethod(flags, methodName, type, null, null)

		if ((flags & <op:ACC_STATIC>) == 0) {
			nArgs += 1	# Allocate a local for "this"
		}

		var maxStackDepth := 0

		var topUsedLocal := nArgs + nELocals - 1
		var maxLocal := topUsedLocal

		println(`nELocals = $nELocals, args = $nArgs`)

		def allocLocal() {
			topUsedLocal += 1
			if (topUsedLocal > maxLocal) {
				maxLocal := topUsedLocal
			}
			return topUsedLocal
		}

		def releaseVar(n :int) {
			require(n == topUsedLocal)
			topUsedLocal -= 1
		}

		def stackAll(types :List) {
			stackType := stackType + types
			if (stackType.size() > maxStackDepth) {
				maxStackDepth := stackType.size()
			}
			#println(`stack: $stackType`)
		}

		def topType(n :(int >= 1)) {
			return stackType[stackType.size() - n]
		}

		def stack(type :String) {
			stackAll([type])
		}

		def unstack(n :int) {
			require(stackType.size() >= n)
			stackType := stackType(0, stackType.size() - n)
			#println(`stack: $stackType`)
		}

		# Update stack for a call to type, ignoring "this"
		def stackFn(type :String) {
			unstack(countArgs(type))
			if (type =~ `@_)V`) {
				return
			}
			stack(returnType(type))
		}

		return def eMethodWriter {
			to topType(n :(int >= 1)) {
				return topType(n)
			}

			to allocLocal() {
				return allocLocal()
			}

			to releaseVar(v) {
				releaseVar(v)
			}

			to eLocalToJaveLocal(i) {
				return i + nArgs
			}

			to constantLong(value) {
				mw.visitLdcInsn(value :<type:long>)
				stack("J")
			}

			to constant(value) {
				switch (value) {
					match x :(int < 256) {
						mw.visitIntInsn(<op:BIPUSH>, x)
						stack("B")
					}
					match x :int {
						mw.visitLdcInsn(value)
						stack("I")
					}
					match x :String {
						mw.visitLdcInsn(value)
						stack("Ljava/lang/String;")
					}
				}
			}

			to constantNull(type :String) {
				mw.visitInsn(<op:ACONST_NULL>)
				stack(type)
			}

			to invokeStatic(klass, verb, type) {
				mw.visitMethodInsn(<op:INVOKESTATIC>, klass, verb, type)
				stackFn(type)
			}

			to invokeInit(targetClassName :String, type :String) {
				mw.visitMethodInsn(<op:INVOKESPECIAL>, targetClassName, "<init>", type)
				stackFn(type)
				unstack(1)
			}

			to loadThis() {
				eMethodWriter.loadLocal(0)
			}

			to loadOurField(fieldName :String, type :String) {
				eMethodWriter.loadField(className, fieldName, type)
			}

			to loadField(targetClassName :String, fieldName :String, type :String) {
				mw.visitFieldInsn(<op:GETFIELD>, targetClassName, fieldName, type)
				unstack(1)
				stack(type)
			}

			to loadStatic(targetClassName :String, fieldName :String, type :String) {
				mw.visitFieldInsn(<op:GETSTATIC>, targetClassName, fieldName, type)
				stack(type)
			}

			to loadFromArray() {
				mw.visitInsn(<op:AALOAD>)
				def arrayType := topType(2)
				unstack(2)	# array, index => value
				require(arrayType[0] == '[')
				stack(arrayType(1))
			}

			to loadLocal(n :int) {
				mw.visitVarInsn(<op:ALOAD>, n)
				stack(localType[n])
			}

			to storeLocal(n :int) {
				mw.visitVarInsn(<op:ASTORE>, n)
				localType[n] := topType(1)
				unstack(1)
			}

			to invokeInterface(name :String, verb :String, type :String) {
				mw.visitMethodInsn(<op:INVOKEINTERFACE>, name, verb, type)
				unstack(1)	# this
				stackFn(type)
			}

			to invokeVirtual(name :String, verb :String, type :String) {
				mw.visitMethodInsn(<op:INVOKEVIRTUAL>, name, verb, type)
				unstack(1)	# this
				stackFn(type)
			}

			to new(type :String) {
				mw.visitTypeInsn(<op:NEW>, type)
				stack(type)
			}

			to newArray(type :String) {
				mw.visitTypeInsn(<op:ANEWARRAY>, type)
				# 0: nItems => array
				unstack(1)
				stack(`[$type`)
			}

			to storeToArray() {
				mw.visitInsn(<op:AASTORE>)
				unstack(3)	# array, index, value
			}

			to dup() {
				mw.visitInsn(<op:DUP>)
				stack(topType(1))
			}

			to dup2() {
				mw.visitInsn(<op:DUP2>)
				stack(topType(2))
				stack(topType(2))
			}

			to pop() {
				mw.visitInsn(<op:POP>)
				unstack(1)
			}

			to swap() {
				mw.visitInsn(<op:SWAP>)
				def a := topType(1)
				def b := topType(2)
				unstack(2)
				stackAll([a, b])
			}

			to dupX1() {
				mw.visitInsn(<op:DUP_X1>)
				def types := stackType(stackType.size() - 2)
				unstack(2)
				stackAll([types[1]] + types)
			}

			to dupX2() {
				mw.visitInsn(<op:DUP_X2>)
				def types := stackType(stackType.size() - 3)
				unstack(3)
				stackAll([types[2]] + types)
			}

			# Stack contains boolean.
			# If true, execute instructions generated by thenMaker()
			# If false, execute elseMaker()
			to ifTrue(thenMaker, elseMaker) {
				def elseBlock := makeLabel()
				def done := makeLabel()

				require(topType(1) == "B")

				mw.visitJumpInsn(<op:IFEQ>, elseBlock)
				unstack(1)
				def oldStack := stackType

				thenMaker()
				def thenStack := stackType
				mw.visitJumpInsn(<op:GOTO>, done)

				stackType := oldStack
				mw.visitLabel(elseBlock)
				elseMaker()
				def elseStack := stackType

				mw.visitLabel(done)

				stackType := unifyBranchTypes(thenStack, elseStack)
			}

			to tryFinally(attemptMaker, finallyMaker) {
				def startAttempt := makeLabel()
				def endAttempt := makeLabel()
				def catchBlock := makeLabel()
				def finallyLabel := makeLabel()
				def done := makeLabel()

				mw.visitTryCatchBlock(startAttempt, endAttempt, catchBlock, null)

				require(stackType.size() == 0, `stack is not empty at start of try block`)

				mw.visitLabel(startAttempt)
				attemptMaker()
				mw.visitLabel(endAttempt)
				def attemptStack := stackType
				mw.visitJumpInsn(<op:JSR>, finallyLabel)
				mw.visitJumpInsn(<op:GOTO>, done)

				# Catch block
				stackType := ["Ljava/lang/Throwable;"]
				mw.visitLabel(catchBlock)
				def exVar := allocLocal()
				eMethodWriter.storeLocal(exVar)	# (must store the exception for type-checking)
				eMethodWriter.constantNull("Ljava/lang/Object;")		# (for consistent stack height)
				def catchStack := stackType
				mw.visitJumpInsn(<op:JSR>, finallyLabel)
				eMethodWriter.loadLocal(exVar)
				mw.visitInsn(<op:ATHROW>)

				# Finally
				stackType := unifyBranchTypes(attemptStack, catchStack)

				# stack: value, returnAddress
				mw.visitLabel(finallyLabel)

				finallyMaker()

				def tmp := allocLocal()
				eMethodWriter.storeLocal(tmp)
				mw.visitIntInsn(<op:RET>, tmp)

				mw.visitLabel(done)
				stackType := attemptStack

				releaseVar(tmp)
				releaseVar(exVar)
			}

			to saveStack(maker) {
				# The JVM clears the stack when an exception is thrown, so copy it
				# to local variables first.
				# save stack
				def stacked := [].diverge()
				while (stackType.size() > 0) {
					def lVar := allocLocal()
					eMethodWriter.storeLocal(lVar)
					stacked.push(lVar)
				}

				maker()

				# store results
				def stackedResults := [].diverge()
				while (stackType.size() > 0) {
					def lVar := allocLocal()
					eMethodWriter.storeLocal(lVar)
					stackedResults.push(lVar)
				}

				require(stackType == [])

				def toRelease := [].diverge()

				# restore stack
				while (stacked.size() > 0) {
					def v := stacked.pop()
					eMethodWriter.loadLocal(v)
					toRelease.push(v)
				}

				# restore results
				while (stackedResults.size() > 0) {
					def v := stackedResults.pop()
					eMethodWriter.loadLocal(v)
					releaseVar(v)
				}

				for v in toRelease {
					releaseVar(v)
				}
			}

			# try:
			#	attempt
			# else:
			#	# on success ...
			# catch:
			#	# on failure ...
			to trySuccessFail(attemptMaker, successMaker, catchMaker) {
				def startAttempt := makeLabel()
				def endAttempt := makeLabel()
				def catchBlock := makeLabel()
				def done := makeLabel()

				# XXX: check nesting. The JVM uses the first matching handler in the table.
				mw.visitTryCatchBlock(startAttempt, endAttempt, catchBlock, null)

				require(stackType.size() == 0, `stack is not empty at start of try block`)

				mw.visitLabel(startAttempt)
				attemptMaker()
				mw.visitLabel(endAttempt)
				# stack: attempt-results

				successMaker()

				def successStack := stackType

				mw.visitJumpInsn(<op:GOTO>, done)

				# Catch block
				stackType := ["Ljava/lang/Throwable;"]
				mw.visitLabel(catchBlock)

				catchMaker()

				# stack: catch-result
				stackType := unifyBranchTypes(successStack, stackType)

				mw.visitLabel(done)
				# stack: result
			}

			to cast(type) {
				mw.visitTypeInsn(<op:CHECKCAST>, type)
				unstack(1)
				stack(`L$type;`)
			}

			to endMethod() {
				println(`endMethod: ss = ${maxStackDepth}, locals = ${maxLocal + 1}`)
				mw.visitMaxs(maxStackDepth + 1, maxLocal + 1)
				mw.visitEnd()
				mw := null
			}

			to aReturn() {
				mw.visitInsn(<op:ARETURN>)
			}
		}
	}
}
