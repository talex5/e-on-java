def countArgs(sig) {
	def `(@args)@_` := sig
	var i:= 0
	var nArgs := 0

	while (i < args.size()) {
		if (args[i] != '[') {
			nArgs += 1
			if (args[i] == 'L') {
				i := args.indexOf1(';', i)
			}
		}
		i += 1
	}
	return nArgs
}

require(countArgs("(Ljava/lang/String;II)V") == 3)
require(countArgs("([Ljava/lang/String;II)V") == 3)
require(countArgs("()V") == 0)

def writerAuthor(<asm>) {
	def makeLabel := <asm:makeLabel>
	def Opcodes := <asm:makeOpcodes>
	def <op> {
		to get(code) {
			return E.call(Opcodes, `get$code`, [])
		}
	}

	return def makeWriter(cw, className :String, flags, methodName :String, type :String, nELocals :int) {
		var mw := cw.visitMethod(flags, methodName, type, null, null)

		var nArgs := countArgs(type)

		if ((flags & <op:ACC_STATIC>) == 0) {
			nArgs += 1	# Allocate a local for "this"
		}

		var maxStackDepth := 0
		var stackDepth := 0

		var topUsedLocal := nArgs + nELocals - 1
		var maxLocal := topUsedLocal

		traceln(`nELocals = $nELocals, args = $nArgs`)

		def allocLocal() {
			topUsedLocal += 1
			if (topUsedLocal > maxLocal) {
				maxLocal := topUsedLocal
			}
			return topUsedLocal
		}

		def releaseVar(n :int) {
			require(n == topUsedLocal)
			topUsedLocal -= 1
		}

		def stack(n :int) {
			stackDepth += n
			require(stackDepth >= 0)
			if (stackDepth > maxStackDepth) {
				maxStackDepth := stackDepth
			}
		}

		# Update stack for a call to type, ignoring "this"
		def stackFn(type :String) {
			stack(0 - countArgs(type))
			if (type =~ `@_)V`) {
				return
			}
			stack(1)	# The return value gets stacked
		}

		return def eMethodWriter {
			to allocLocal() {
				return allocLocal()
			}

			to releaseVar(v) {
				releaseVar(v)
			}

			to eLocalToJaveLocal(i) {
				return i + nArgs
			}

			to constantLong(value) {
				mw.visitLdcInsn(value :<type:long>)
				stack(1)
			}

			to constant(value) {
				if (value =~ x :(int < 256)) {
					mw.visitIntInsn(<op:BIPUSH>, x)
				} else if (value == null) {
					mw.visitInsn(<op:ACONST_NULL>)
				} else {
					mw.visitLdcInsn(value)
				}
				stack(1)
			}

			to invokeStatic(klass, verb, type) {
				mw.visitMethodInsn(<op:INVOKESTATIC>, klass, verb, type)
				stackFn(type)
			}

			to invokeInit(targetClassName :String, type :String) {
				mw.visitMethodInsn(<op:INVOKESPECIAL>, targetClassName, "<init>", type)
				stackFn(type)
				stack(-1)
			}

			to loadThis() {
				eMethodWriter.loadLocal(0)
			}

			to loadOurField(fieldName :String, type :String) {
				eMethodWriter.loadField(className, fieldName, type)
			}

			to loadField(targetClassName :String, fieldName :String, type :String) {
				mw.visitFieldInsn(<op:GETFIELD>, targetClassName, fieldName, type)
			}

			to loadFromArray() {
				mw.visitInsn(<op:AALOAD>)
				stack(-1)	# array, index => value
			}

			to loadLocal(n :int) {
				mw.visitVarInsn(<op:ALOAD>, n)
				stack(1)
			}

			to storeLocal(n :int) {
				mw.visitVarInsn(<op:ASTORE>, n)
				stack(-1)
			}

			to invokeInterface(name :String, verb :String, type :String) {
				mw.visitMethodInsn(<op:INVOKEINTERFACE>, name, verb, type)
				stackFn(type)
				stack(-1)	# this
			}

			to invokeVirtual(name :String, verb :String, type :String) {
				mw.visitMethodInsn(<op:INVOKEVIRTUAL>, name, verb, type)
				stackFn(type)
				stack(-1)	# this
			}

			to new(type :String) {
				mw.visitTypeInsn(<op:NEW>, type)
				stack(1)
			}

			to newArray(type :String) {
				mw.visitTypeInsn(<op:ANEWARRAY>, type)
				# 0: nItems => array
			}

			to storeToArray() {
				mw.visitInsn(<op:AASTORE>)
				stack(-3)	# array, index, value
			}

			to dup() {
				mw.visitInsn(<op:DUP>)
				stack(1)
			}

			to dup2() {
				mw.visitInsn(<op:DUP2>)
				stack(2)
			}

			to pop() {
				mw.visitInsn(<op:POP>)
				stack(-1)
			}

			to swap() {
				mw.visitInsn(<op:SWAP>)
			}

			to dupX1() {
				mw.visitInsn(<op:DUP_X1>)
				stack(1)
			}

			to dupX2() {
				mw.visitInsn(<op:DUP_X2>)
				stack(1)
			}

			# Stack contains boolean.
			# If true, execute instructions generated by thenMaker()
			# If false, execute elseMaker()
			to ifTrue(thenMaker, elseMaker) {
				require(stackDepth == 1)

				def elseBlock := makeLabel()
				def done := makeLabel()

				mw.visitJumpInsn(<op:IFEQ>, elseBlock)
				stack(-1)
				def oldStack := stackDepth

				thenMaker()
				def thenStack := stackDepth
				mw.visitJumpInsn(<op:GOTO>, done)

				stackDepth := oldStack
				mw.visitLabel(elseBlock)
				elseMaker()
				def elseStack := stackDepth

				mw.visitLabel(done)

				require(thenStack == elseStack, `then stack gives $thenStack; else gives $elseStack)`)
			}

			to tryFinally(attemptMaker, finallyMaker) {
				def startAttempt := makeLabel()
				def endAttempt := makeLabel()
				def catchBlock := makeLabel()
				def finallyLabel := makeLabel()
				def done := makeLabel()

				mw.visitTryCatchBlock(startAttempt, endAttempt, catchBlock, null)

				require(stackDepth == 0, `stack is $stackDepth at start of try block`)

				mw.visitLabel(startAttempt)
				attemptMaker()
				mw.visitLabel(endAttempt)
				def attemptStack := stackDepth
				mw.visitJumpInsn(<op:JSR>, finallyLabel)
				mw.visitJumpInsn(<op:GOTO>, done)

				# Catch block
				stackDepth := 1		# the exception
				mw.visitLabel(catchBlock)
				def exVar := allocLocal()
				eMethodWriter.storeLocal(exVar)	# (must store the exception for type-checking)
				eMethodWriter.constant(null)		# (for consistent stack height)
				def catchStack := stackDepth
				mw.visitJumpInsn(<op:JSR>, finallyLabel)
				eMethodWriter.loadLocal(exVar)
				mw.visitInsn(<op:ATHROW>)

				# Finally
				require(catchStack == attemptStack, `attempt: $attemptStack, catch: $catchStack`)
				stackDepth := catchStack

				# stack: value, returnAddress
				mw.visitLabel(finallyLabel)

				finallyMaker()

				def tmp := allocLocal()
				eMethodWriter.storeLocal(tmp)
				mw.visitIntInsn(<op:RET>, tmp)

				mw.visitLabel(done)
				stackDepth := attemptStack

				releaseVar(tmp)
				releaseVar(exVar)
			}

			to saveStack(maker) {
				# The JVM clears the stack when an exception is thrown, so copy it
				# to local variables first.
				# save stack
				def stacked := [].diverge()
				while (stackDepth > 0) {
					def lVar := allocLocal()
					eMethodWriter.storeLocal(lVar)
					stacked.push(lVar)
				}

				def oldStack := stackDepth
				maker()

				# store results
				def stackedResults := [].diverge()
				while (stackDepth > 0) {
					def lVar := allocLocal()
					eMethodWriter.storeLocal(lVar)
					stackedResults.push(lVar)
				}

				require(oldStack == stackDepth)

				def toRelease := [].diverge()

				# restore stack
				while (stacked.size() > 0) {
					def v := stacked.pop()
					eMethodWriter.loadLocal(v)
					toRelease.push(v)
				}

				# restore results
				while (stackedResults.size() > 0) {
					def v := stackedResults.pop()
					eMethodWriter.loadLocal(v)
					releaseVar(v)
				}

				for v in toRelease {
					releaseVar(v)
				}
			}

			# try:
			#	attempt
			# else:
			#	# on success ...
			# catch:
			#	# on failure ...
			to trySuccessFail(attemptMaker, successMaker, catchMaker) {
				def startAttempt := makeLabel()
				def endAttempt := makeLabel()
				def catchBlock := makeLabel()
				def done := makeLabel()

				# XXX: check nesting. The JVM uses the first matching handler in the table.
				mw.visitTryCatchBlock(startAttempt, endAttempt, catchBlock, null)

				require(stackDepth == 0, `stack is $stackDepth at start of try block`)

				mw.visitLabel(startAttempt)
				attemptMaker()
				mw.visitLabel(endAttempt)
				# stack: attempt-results

				successMaker()

				def successStack := stackDepth

				mw.visitJumpInsn(<op:GOTO>, done)

				# Catch block
				stackDepth := 1		# the exception
				mw.visitLabel(catchBlock)

				catchMaker()

				# stack: catch-result
				require(stackDepth == successStack, `success: $successStack, catch: $stackDepth`)

				mw.visitLabel(done)
				# stack: result
			}

			to endMethod() {
				traceln(`endMethod: ss = ${maxStackDepth}, locals = ${maxLocal + 1}`)
				mw.visitMaxs(maxStackDepth + 1, maxLocal + 1)
				mw.visitEnd()
				mw := null
			}

			to aReturn() {
				mw.visitInsn(<op:ARETURN>)
			}
		}
	}
}
